import { Head, Image, Appear } from 'mdx-deck'
import { Split } from 'mdx-deck/layouts'
import { SplitRight } from 'mdx-deck/layouts'
import { default as SyntaxHighlighter } from 'react-syntax-highlighter';
import { darcula } from 'react-syntax-highlighter/styles/hljs'
export { default as theme } from './theme'
import { CodeSurfer } from "mdx-deck-code-surfer"

<Head>
  <title>Nubank Clojure</title>
</Head>

<!-- # Nubank & Clojure -->
<Image src="./img/nulogo.png" size="40%" />

---

export default Split

# Quem Somos

Leonardo Iacovini

leonardo.iacovini@nubank.com.br

<br />

Rafael Leal

rafael.leal@nubank.com.br

---

export default Split

# Nubank

- Cart√£o de Cr√©dito (2014)
- Rewards (2016)
- NuConta (2017)
- Cart√£o de D√©bito (2018)
- Empr√©stimos (2019)


- 6 milh√µes de clientes
- Mais de 220 Engenheiros
- Mais de 200 Microservi√ßos Clojure

---

# Tecnologias

- Microservi√ßos
- Clojure
- Kafka
- Datomic
- Kubernetes
- AWS
- ...

---

# Clojure

- LISP
- Funcional
- JVM
- REPL

<img width="20%" src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/5d/Clojure_logo.svg/1200px-Clojure_logo.svg.png" />

---

# LISP

- Parenteses!
- _Code is Data_
- Primeira apari√ß√£o em 1958
- Common Lisp, Scheme, Clojure (entre outros)!

---

<Image src="https://imgs.xkcd.com/comics/lisp_cycles.png" size="90%"/>

---

<div style={{textAlign: 'left', fontSize: 80}}>
  JS
  <SyntaxHighlighter language='javascript' style={darcula}>
    {`function(arg1, arg2)`}
  </SyntaxHighlighter>
  Clojure
  <SyntaxHighlighter language='clojure' style={darcula}>
    {`(function arg1 arg2)`}
  </SyntaxHighlighter>
</div>

---

## Clojure √© um _dialeto LISP_

Dialeto √© uma variante lingu√≠stica constitu√≠da por caracter√≠sticas fonol√≥gicas, sint√°ticas, sem√¢nticas e morfol√≥gicas pr√≥prias.

---

<Image src="https://i.kym-cdn.com/photos/images/newsfeed/000/173/576/Wat8.jpg?1315930535" size="70%" />

---

Clojure segue a mesma estrutura gramatical e sint√°tica de um LISP, por√©m possui suas carater√≠sticas pr√≥prias de execu√ß√£o e padr√µes

---

# Exemplo (Fatorial)

<div style={{textAlign: 'left', fontSize: 70}}>
  <SyntaxHighlighter language='clojure' style={darcula} wrapLines={false}>
    {require("!raw-loader!./snippets/fatorial.clj")}
  </SyntaxHighlighter>
</div>

---

# Programa√ß√£o Funcional

_Paradigma_ de programa√ß√£o que procura tratar problemas computacionais como a avalia√ß√£o de fun√ß√µes matem√°ticas, tem suas origens no c√°lculo Lambda

- Clojure
- Elixir
- Scala
- Haskell
- F#

---

- Fun√ß√µes puras
- Imutabilidade
- Idempot√™ncia (livre de _side-effects_)
- Fun√ß√µes s√£o valores (First Class Functions)
- Transpar√™ncia referencial
- Programa√ß√£o declarativa

---

# Funcional?

<div style={{textAlign: 'left', fontSize: 30}}>
  <SyntaxHighlighter language='c' style={darcula} wrapLines={false}>
    {require("!raw-loader!./snippets/not-a-function.c")}
  </SyntaxHighlighter>
</div>
<Appear>
<span style={{fontSize: 80}}>
  "Uma rela√ß√£o f:A‚ÜíB √© uma fun√ß√£o quando para qualquer x ‚àà A existe um √∫nico (x,y) ‚àà f."
</span>
  </Appear>

---

# Fun√ß√µes Puras

Os dados recebidos n√£o s√£o alterados. Um novo valor √© criado e retornado

S√£o fun√ß√µes livre de efeitos colaterais

Efeitos colaterais s√£o a√ß√µes que alteram o estado do mundo (Eg: enviar um email, fazer uma transa√ß√£o no DB, etc...)

Fun√ß√µes puras s√£o f√°ceis de entender, testar e seguras de executar! (idempotentes)

---

# Imutabilidade

- _Vari√°veis_ n√£o tem seu valor alterado

Se `a = 1`, ent√£o `a` sempre ser√° `1`

- Fun√ß√µes n√£o alteram o valor de suas entradas, elas produzem uma s√°ida com as altera√ß√µes feitas.

`f(a) -> b` onde `b != a` (outro _objeto_ - n√£o √© a mesma refer√™ncia)

---

# Vantagens

- Programa√ß√£o concorrente/paralelismos (thread safety)
- Fica mais f√°cil entender o que o c√≥digo est√° fazendo
- Facilidade para testar

---

# Performace

Isso n√£o deveria piorar a performace? (Listas por exemplo)

Preciso ficar copiando as estruturas toda manipula√ß√£o ?

---

# N√ÉO

Clojure usa estruturas de dados otimizadas para opera√ß√µes imut√°veis, a maioria das opera√ß√µes √© feita em O(1).

Se utiliza de tecnicas de re-aproveitamento de mem√≥ria (j√° que os dados n√£o mudam - copy-on-write)

---

Imutabilidade elimina grande parte dos problemas que ocasionam dead-locks e problemas de concorr√™ncia, simplificando nosso c√≥digo

<div style={{textAlign: 'left'}}>
<SyntaxHighlighter language='java' style={darcula}>
{`lock.lock();
doSomething();
lock.unlock();`}
</SyntaxHighlighter>

<SyntaxHighlighter language='java' style={darcula}>
{`synchronized (Lock lock) {
    doSomething()
}`}
</SyntaxHighlighter>
</div>

<span style={{fontSize: 100}}>ü§î</span>

---

export default Split

<div style={{textAlign: 'left'}}>
  Mut√°vel
  <SyntaxHighlighter language='c' style={darcula} wrapLines={false}>
    {require("!raw-loader!./snippets/mutable-fat.c")}
  </SyntaxHighlighter>
</div>

<div style={{textAlign: 'left'}}>
  Imut√°vel
  <SyntaxHighlighter language='clojure' style={darcula} wrapLines={false}>
    {require("!raw-loader!./snippets/fatorial.clj")}
  </SyntaxHighlighter>
</div>

---

# Idempot√™ncia

Em matem√°tica e ci√™ncia da computa√ß√£o, a idempot√™ncia √© a propriedade que algumas opera√ß√µes t√™m de poderem ser aplicadas v√°rias vezes sem que o valor do resultado se altere ap√≥s a aplica√ß√£o inicial.

`f(f(x)) = f(x)`

---

In imperative programming, a subroutine with side effects is idempotent if the system state remains the same after one or several calls, in other words if the function from the system state space to 
itself associated to the subroutine is idempotent in the mathematical sense given in the definition;

---

# Fun√ß√µes s√£o Valores

Fun√ß√µes s√£o tratadas como demais tipos (inteiros, float, strings, etc...), e podem ser atribuidas a _vari√°veis_, passadas como argumentos
ou retornadas por outras fun√ß√µes.

---

# High Order Functions

S√£o fun√ß√µes que recebem outras fun√ß√µes como argumento

Ou, fun√ß√µes que retornam outras fun√ß√µes

`f(g(x))  === f‚àòg`

`f(g, a) -> b`

`f(a, b) -> g`

onde `f` e `g` s√£o fun√ß√µes

---

<div style={{textAlign: 'left', fontSize: 50}}>
  <SyntaxHighlighter language='clojure' style={darcula} wrapLines={false}>
    {require("!raw-loader!./snippets/map.clj")}
  </SyntaxHighlighter>
  <SyntaxHighlighter language='clojure' style={darcula} wrapLines={false}>
    {require("!raw-loader!./snippets/even.clj")}
  </SyntaxHighlighter>
  <SyntaxHighlighter language='clojure' style={darcula} wrapLines={false}>
    {require("!raw-loader!./snippets/comp.clj")}
  </SyntaxHighlighter>
</div>

---

# HoF Comuns

<div style={{textAlign: 'left', fontSize: 60}}>
  <SyntaxHighlighter language='clojure' style={darcula} wrapLines={false}>
    {require("!raw-loader!./snippets/common-hofs.clj")}
  </SyntaxHighlighter>
</div>

Opera√ß√µes em sequ√™ncias!

---

# Refer√™ncia Transparencial

O resultado de uma fun√ß√£o depende apenas dos argumentos que ela recebe

Caracter√≠stica de fun√ß√µes puras

---

# Clojure

<img width="50%" src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/5d/Clojure_logo.svg/1200px-Clojure_logo.svg.png" />

https://clojure.org/

---

- Roda na JVM, tem interop com outras linguagens que tamb√©m rodam nela (Java, Scala, Groovy, etc...)
- Din√¢mica
- _REPL Driven Development_
- Criada por Rich Hickey
- Simples e intuitiva!

---

# Tipos

<div style={{textAlign: 'left', fontSize: 50}}>
  <SyntaxHighlighter language='clojure' style={darcula} wrapLines={false}>
    {require("!raw-loader!./snippets/types.clj")}
  </SyntaxHighlighter>
</div>

---

> "It is better to have 100 functions operate on one data structure than to have 10 functions operate on 10 data structures." - Alan Perlis

---

# N√∫meros

`BigDecimal` e `BigInteger` s√£o nativos do Clojure, voc√™ pode fazer opera√ß√µes com extrema alta precis√£o usando todos m√©todos e operadores
nativos. (muito √∫til para uma institui√ß√£o financeira)

`Ratio` √© um tipo de Clojure que permite expressar fra√ß√µes e propor√ß√µes com precis√£o infinita, como por exemplo `1/3`

---

# Fun√ß√µes

Fun√ß√µes em clojure podem ser criadas usando `fn`:

<div style={{textAlign: 'left', fontSize: 50}}>
  <SyntaxHighlighter language='clojure' style={darcula} wrapLines={false}>
    {`(fn [arg] body)
(def my-fn (fn [arg] body))
(defn my-fn [arg] body)
#(inc %) ;; => (fn [a] (inc a))`}
  </SyntaxHighlighter>
</div>

---

# Mapas

Mapas `{}` s√£o usados muito em Clojure para carregar valores juntos (o que geralmente seria um objeto), mas ele cont√©m apenas os valores imut√°veis
e n√£o opera√ß√µes que alteram seu estado.

Geralmente `keywords` s√£o usadas como chaves para os mapas

<div style={{textAlign: 'left', fontSize: 50}}>
  <SyntaxHighlighter language='clojure' style={darcula} wrapLines={false}>
    {`{:name           "John"
 :account-number 3456
 :branch         1}`}
  </SyntaxHighlighter>
</div>

---

# Sequences

Clojure conta com 2 tipos para sequ√™ncias: `List '()` e `Vector []`

Ambas s√£o bem semelhantes e funcionam de forma da mesma maneira em diferentes fun√ß√µes e cen√°rios, por√©m existem algumas diferen√ßas de comportamentos, como por exemplo:

`Lists` tem elementos adicionados no seu in√≠cios, `Vectors` tem elementos adicionados no final, quando usando a fun√ß√£o `conj`

---

## Sequ√™ncias s√£o elementos fudamentais em programa√ß√£o funcional, e em Clojure. Processar e transformar sequ√™ncias de dados √© parte central de muitos programas

---

# Blocos

<div style={{textAlign: 'left', fontSize: 50}}>
  <SyntaxHighlighter language='clojure' style={darcula} wrapLines={false}>
    {require("!raw-loader!./snippets/blocks.clj")}
  </SyntaxHighlighter>
</div>

---

# Recurs√£o

Recurs√£o √© uma ferramenta importante em programa√ß√£o funcional, pois permite que executemos "loops" sem alterar o valor das vari√°veis

<div style={{textAlign: 'left', fontSize: 50}}>
  <SyntaxHighlighter language='clojure' style={darcula} wrapLines={false}>
    {require("!raw-loader!./snippets/recur.clj")}
  </SyntaxHighlighter>
</div>

---

# Loop

Permite realizar loops dentro de fun√ß√µes, como se tivessemos uma recurs√£o localizada.

<div style={{textAlign: 'left', fontSize: 50}}>
  <SyntaxHighlighter language='clojure' style={darcula} wrapLines={false}>
    {require("!raw-loader!./snippets/loops.clj")}
  </SyntaxHighlighter>
</div>

---

# Dica!

Prefira sempre utilizar sempre que poss√≠vel fun√ß√µes como `map`, `filter`, `reduce`, etc... E composi√ß√µes delas, ao inv√©s de recurs√£o e `loop`.

Elas deixam seu c√≥digo mais limpo, funcional e f√°cil de entender. Recurs√£o deve ser utilizada quando ela for realmente a melhor op√ß√£o (ou √∫nica)

---

# Keywords

`keywords` s√£o um tipo muito usado em Clojure, geralmente s√£o usadas como chaves de mapas, ou identificadores (como valores de um Enum)

`keywords` podem (e muitas vezes s√£o) usadas com namespaces, como por exemplo: `:person/name`. Isso ajuda a *qualificar* a `keywords`

`keywords` tamb√©m s√£o fun√ß√µes! Voc√™ pode acessar valores de um mapa usando elas: `(:name {:name "John"})` => `"John"`

---

# Sets

`sets #{1 2 3}` s√£o cole√ß√µes como seq√™ncias, s√≥ que sem uma ordem definida, e n√£o podem ter elementos repetidos.

`sets` tamb√©m s√£o fun√ß√µes! Usando um `set`, podemos saber se um elemento est√° contido nele: 

`(#{1 2 3} 1)` => `1`

`(#{1 2 3} 5)` => `nil`


---

# Code is Data

O c√≥digo Clojure em s√≠ √© uma sequ√™ncia de s√≠mbolos em uma `list`

---

# Macros

S√£o _fun√ß√µes_ que operam sobre a estrutura do c√≥digo para modifica-lo antes da compila√ß√£o ou execu√ß√£o

Exemplo: Thread Last Macro `->>`
<div style={{textAlign: 'left', fontSize: 50}}>
  <SyntaxHighlighter language='clojure' style={darcula} wrapLines={false}>
    {require("!raw-loader!./snippets/macros.clj")}
  </SyntaxHighlighter>
</div>

---

# DEMO

---

<div style={{textAlign: 'left', fontSize: 20}}>
  <SyntaxHighlighter language='clojure' style={darcula} wrapLines={false}>
    {require("!raw-loader!./snippets/billing.clj")}
  </SyntaxHighlighter>
</div>

---

# Interop Java

Clojure consegue realizar interop com Java, e com isso ganhamos todo acervo que a JVM nos fornece.

<div style={{textAlign: 'left', fontSize: 30}}>
  <SyntaxHighlighter language='clojure' style={darcula} wrapLines={false}>
    {require("!raw-loader!./snippets/interop.clj")}
  </SyntaxHighlighter>
</div>

(n√£o abuse do interop - use somente quando necess√°rio - Clojure fornece uma biblioteca repleta de recursos)

---

# Concorr√™ncia e Paralelismo

Clojure √© feito pensando em concorr√™ncia, ele nos prov√™ nativamente v√°rias fun√ß√µes para ajudar com isso!

- `pmap` -> Como o `map` s√≥ que paraleliza automaticamente o processamento
- `future`
- `promise`

---

# Mas... E quando precisamos de estado?

---

# Estado Mut√°vel

Quando precisamos trabalhar com estado mut√°vel, Clojure possui estruturas de dados pr√≥prias para isso, como por exemplo o `atom`

<div style={{textAlign: 'left', fontSize: 30}}>
  <SyntaxHighlighter language='clojure' style={darcula} wrapLines={false}>
    {require("!raw-loader!./snippets/atom.clj")}
  </SyntaxHighlighter>
</div>

---

# Estamos Contratando!

---

<img src="./img/qr.png" width="30%"/>

http://bit.ly/2C4B6cD